// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`per type field generation with casual with dynamic values can accept an extra function call 1`] = `
"import casual from 'casual';

casual.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual['integer'](...[1,100]).toFixed(),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => casual.seed(seed);
"
`;

exports[`per type field generation with casual with dynamic values can accept an extra function call with arguments 1`] = `
"import casual from 'casual';

casual.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual['integer'](...[1,100]).toFixed(...[3]),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => casual.seed(seed);
"
`;

exports[`per type field generation with casual with dynamic values can accept an extra function call with arguments shorthand 1`] = `
"import casual from 'casual';

casual.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual['integer'](...[1,100]).toFixed(...[3]),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => casual.seed(seed);
"
`;

exports[`per type field generation with casual with dynamic values can accept arguments 1`] = `
"import casual from 'casual';

casual.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual['integer'](...[1,100]),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => casual.seed(seed);
"
`;

exports[`per type field generation with casual with dynamic values can apply generator override to all fields of a specific name 1`] = `
"import casual from 'casual';

casual.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['email'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['email'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => casual.seed(seed);
"
`;

exports[`per type field generation with casual with dynamic values can overwrite a scalar value 1`] = `
"import casual from 'casual';

casual.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['email'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => casual.seed(seed);
"
`;

exports[`per type field generation with casual with dynamic values can overwrite an enum value 1`] = `
"import casual from 'casual';

casual.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : casual['email'],
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => casual.seed(seed);
"
`;

exports[`per type field generation with casual with dynamic values can overwrite an enum value when enumsAsTypes is true 1`] = `
"import casual from 'casual';

casual.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : casual['email'],
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => casual.seed(seed);
"
`;

exports[`per type field generation with casual with dynamic values uses per field generation if field name matches 1`] = `
"import casual from 'casual';

casual.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['email'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : casual['word'],
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : casual['date'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : casual['date'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : casual.word,
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : casual['word'],
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => casual.seed(seed);
"
`;

exports[`per type field generation with casual without dynamic values can accept an extra function call 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'ea',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'vero',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '2004-01-01',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '1995-09-05',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : '39',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'consectetur',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'quibusdam',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '1980-12-10',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '2014-12-19',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'ut',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'voluptas',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with casual without dynamic values can accept an extra function call with arguments 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'ea',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'vero',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '2004-01-01',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '1995-09-05',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : '39.000',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'consectetur',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'quibusdam',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '1980-12-10',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '2014-12-19',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'ut',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'voluptas',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with casual without dynamic values can accept an extra function call with arguments shorthand 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'ea',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'vero',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '2004-01-01',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '1995-09-05',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : '39.000',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'consectetur',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'quibusdam',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '1980-12-10',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '2014-12-19',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'ut',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'voluptas',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with casual without dynamic values can accept arguments 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'ea',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'vero',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '2004-01-01',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '1995-09-05',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 39,
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'consectetur',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'quibusdam',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '1980-12-10',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '2014-12-19',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'ut',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'voluptas',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with casual without dynamic values can apply generator override to all fields of a specific name 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'ea',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'Schuppe.Demario@yahoo.com',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '2004-01-01',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '1995-09-05',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'vel',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'consectetur',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'Molly.Wuckert@gmail.com',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '1980-12-10',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '2014-12-19',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'ut',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'voluptas',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with casual without dynamic values can overwrite a scalar value 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'ea',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'Schuppe.Demario@yahoo.com',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '2004-01-01',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '1995-09-05',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'vel',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'consectetur',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'quibusdam',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '1980-12-10',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '2014-12-19',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'ut',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'voluptas',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with casual without dynamic values can overwrite an enum value 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'ea',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'vero',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '2004-01-01',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '1995-09-05',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'vel',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'consectetur',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'quibusdam',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '1980-12-10',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '2014-12-19',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'ut',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'voluptas',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : 'Roosevelt.Oberbrunner@gmail.com',
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with casual without dynamic values can overwrite an enum value when enumsAsTypes is true 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'ea',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'vero',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '2004-01-01',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '1995-09-05',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'vel',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'consectetur',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'quibusdam',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '1980-12-10',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '2014-12-19',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'ut',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'voluptas',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : 'Roosevelt.Oberbrunner@gmail.com',
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with casual without dynamic values uses per field generation if field name matches 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'ea',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'Schuppe.Demario@yahoo.com',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '2004-01-01',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '1995-09-05',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'vel',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'consectetur',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'quibusdam',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : '1980-12-10',
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : '2014-12-19',
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'ut',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : datatype.integer,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'voluptas',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with faker with dynamic values can accept an extra function call 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker['date']['recent'](...[10]).toLocaleDateString(),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker with dynamic values can accept an extra function call with arguments 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker['date']['recent'](...[10]).toLocaleDateString(...[\\"en-GB\\"]),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker with dynamic values can accept an extra function call with arguments shorthand 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker['date']['recent'](...[10]).toLocaleDateString(...[\\"en-GB\\"]),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker with dynamic values can accept arguments 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker['date']['recent'](...[10]),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker with dynamic values can apply generator override to all fields of a specific name 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['internet']['email'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['internet']['email'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker with dynamic values can overwrite a nested value with null 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : null,
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker with dynamic values can overwrite a nested value with null when terminateCircularRelationships is true 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>, _relationshipsToOmit: Set<string> = new Set()): A => {
    const relationshipsToOmit: Set<string> = new Set(_relationshipsToOmit);
    relationshipsToOmit.add('A');
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aB = (overrides?: Partial<B>, _relationshipsToOmit: Set<string> = new Set()): B => {
    const relationshipsToOmit: Set<string> = new Set(_relationshipsToOmit);
    relationshipsToOmit.add('B');
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>, _relationshipsToOmit: Set<string> = new Set()): C => {
    const relationshipsToOmit: Set<string> = new Set(_relationshipsToOmit);
    relationshipsToOmit.add('C');
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>, _relationshipsToOmit: Set<string> = new Set()): D => {
    const relationshipsToOmit: Set<string> = new Set(_relationshipsToOmit);
    relationshipsToOmit.add('D');
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : null,
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker with dynamic values can overwrite a scalar value 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['internet']['email'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['past'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker with dynamic values can overwrite an enum value 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : faker['helpers']['arrayElement'](...[[\\"active\\",\\"disabled\\"]]),
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker with dynamic values can overwrite an enum value when enumsAsTypes is true 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : faker['helpers']['arrayElement'](...[[\\"active\\",\\"disabled\\"]]),
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker with dynamic values uses per field generation if field name matches 1`] = `
"import { faker } from '@faker-js/faker';

faker.seed(0);

export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['internet']['email'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : faker['lorem']['sentence'](),
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : faker['date']['future'](),
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : faker['date']['future'](),
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : faker.lorem.word(),
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : faker['datatype']['number'](...[{\\"min\\":1,\\"max\\":100}]),
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : faker['lorem']['sentence'](),
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};

export const seedMocks = (seed: number) => faker.seed(seed);
"
`;

exports[`per type field generation with faker without dynamic values can accept an extra function call 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : '1/1/2022',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with faker without dynamic values can accept an extra function call with arguments 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : '01/01/2022',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with faker without dynamic values can accept arguments 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : \\"2022-01-01T00:00:00.000Z\\",
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with faker without dynamic values can apply generator override to all fields of a specific name 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'my@email.com',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'my@email.com',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with faker without dynamic values can overwrite a scalar value 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'my@email.com',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2020-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with faker without dynamic values can overwrite an enum value 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : 'my@email.com',
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with faker without dynamic values can overwrite an enum value when enumsAsTypes is true 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : 'my@email.com',
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;

exports[`per type field generation with faker without dynamic values uses per field generation if field name matches 1`] = `
"
export const anA = (overrides?: Partial<A>): A => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'my@email.com',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aB = (overrides?: Partial<B>): B => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        email: overrides && overrides.hasOwnProperty('email') ? overrides.email! : 'A sentence',
        date: overrides && overrides.hasOwnProperty('date') ? overrides.date! : \\"2050-01-01T00:00:00.000Z\\",
        overriddenDate: overrides && overrides.hasOwnProperty('overriddenDate') ? overrides.overriddenDate! : \\"2050-01-01T00:00:00.000Z\\",
        dateTime: overrides && overrides.hasOwnProperty('dateTime') ? overrides.dateTime! : 'Word',
    };
};

export const aC = (overrides?: Partial<C>): C => {
    return {
        id: overrides && overrides.hasOwnProperty('id') ? overrides.id! : 1,
        str: overrides && overrides.hasOwnProperty('str') ? overrides.str! : 'A sentence',
        enum: overrides && overrides.hasOwnProperty('enum') ? overrides.enum! : EnumExample.Lorem,
    };
};

export const aD = (overrides?: Partial<D>): D => {
    return {
        nested: overrides && overrides.hasOwnProperty('nested') ? overrides.nested! : aC(),
    };
};
"
`;
